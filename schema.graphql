scalar Date

enum Fortnight {
  FIRST
  SECOND
}

# Deprecated: Use new Category type instead
enum Category {
  BILLS
  CAR
  CLOTHES
  COMMUNICATION
  EATING_OUT
  ENTERTAINMENT
  FOOD
  GIFTS
  HEALTH
  HOUSE
  INSURANCE
  MONTHS_WITHOUT_INTEREST
  PETS
  SPORTS
  TRANSPORT
  SUPER_MARKET
  HANG_OUT
  SAVINGS
  SUBSCRIPTION
  FIXED_EXPENSE
}

enum FixedExpenseFrequency {
  Biweekly
  Monthly
}

type CategoryType {
  id: ID!
  userId: ID
  name: String!
  percentage: Float
}

type SubCategory {
  id: ID!
  userId: ID
  name: String!
}

type Categories {
  id: ID
  userId: ID
  name: String
  subCategory: [SubCategory!]
}

type CategorySettings {
  settings: [CategoryType!]
  percentageTotal: Float!
}

type CategoryAllocation {
  categorySum: [CategorySum]
  income: Income
  expenses: [Expense]
}

type CategorySum {
  category: CategoryType!
  allocated: String!
  remaining: String!
  sum: String!
}

interface Total {
  date: String!
  total: Float!
  month: String!
  year: String!
}

type PaymentDate {
  date: String!
  fortnight: Fortnight!
}

type Period {
  id: ID!
  userId: String!
  startDate: String!
  endDate: String!
  createdAt: String
  updatedAt: String
}

type Income {
  id: ID!
  userId: String!
  total: String!
  period: Period
  createdAt: Date
  updatedAt: Date
  comment: String
  paymentDate: PaymentDate!
  # Add a field for "safe to spend" and maybe one for "savings"
}

type TotalByMonth implements Total {
  date: String!
  total: Float!
  month: String!
  year: String!
}

type TotalByFortnight implements Total {
  date: String!
  month: String!
  fortnight: Fortnight!
  total: Float!
  year: String!
}

# Type used to display all the incomes registered and to obtain the total by month
# and total of all
type IncomesList {
  incomes: [Income!]!
  totalByMonth: [TotalByMonth!]!
  total: Float!
}

type IncomesGroupedBy {
  month: String!
  year: String!
  total: String!
  incomes: [Income!]!
}

# TODO add query to return total of card expenses by fortnight
type Card {
  id: ID!
  userId: ID!
  alias: String
  bank: String!
  isDigital: Boolean
  isDebit: Boolean
}

type TotalByCardId {
  totalByMonth: [TotalByMonth]
  totalByFortnight: [TotalByFortnight]
}

type Expense {
  id: ID!
  userId: String
  periodId:String
  concept: String!
  total: String!
  payBefore: Date!
  createdAt: Date
  updatedAt: Date
  card: Card
  comment: String
  category: CategoryType!
  subCategory: SubCategory!
}

type GroupedExpenses {
  date: String!
  expenses: [Expense!]
  total: String!
}

type FinancialBalance {
  remaining: Float!
  debts: Float!
}

# Type used to display the income for a given fortnight and all the related expenses
# it also return the total of all the expenses and the remaining between income and expenses
type IncomesListAndExpenses {
  incomes: [Income!]
  groupedExpenses: [GroupedExpenses!]
  incomesTotal: String!
  expensesTotal: String
  remaining: String
}

type ExpensesBy {
  expenses: [Expense]
  expensesTotal: Float
}

type CategorySetting {
  id: ID!
  message: String!
}

enum AUTH_STATUS {
  AUTHENTICATED
  UNAUTHENTICATED
}

type LoginResponse {
  status: AUTH_STATUS!
}

input CreateIncomeInput {
  total: Float!
  comment: String
  paymentDate: Date!
}

input UpdateIncomeInput {
  incomeId: ID!
  total: Float!
  comment: String
  paymentDate: Date!
}

input CreateExpenseInput {
  cardId: ID
  concept: String!
  total: Float!
  payBefore: Date!
  periodId: String!
  comment: String
  categoryId: String!
  subCategoryId: String!
}

input CreateFixedExpenseInput {
  cardId: ID
  concept: String!
  total: Float!
  payBefore: Date!
  comment: String
  category: Category!
  numberOfMonthsOrWeeks: Int!
  frequency: FixedExpenseFrequency
}

input UpdateExpenseInput {
  id: ID!
  cardId: ID
  concept: String!
  total: Float!
  payBefore: Date!
  comment: String
  category: Category!
}

input CreateCardInput {
  alias: String
  bank: String!
  isDigital: Boolean
  isDebit: Boolean
}

input UpdateCardInput {
  id: ID!
  alias: String
  bank: String!
  isDigital: Boolean
  isDebit: Boolean
}

input PayBeforeInput {
  payBefore: Date
  periodId: String
  cardId: ID
}

input FilterInput {
  cardId: ID
  periodId: ID
  startDate: Date
  endDate: Date
  subCategoryIds: [ID!]
  # inputs used t filter granualiry
  month: String
  year: String
}

input initialDate {
  year: Int
  month: Int
  day: Int
}

input endDate {
  year: Int
  month: Int
  day: Int
}

input AllExpensesByDateRangeInput {
  initialDate: initialDate
  endDate: endDate
}

input CategoryAllocationInput {
  periodId: String!
  incomeId: String!
}

input CreateCategorySettingInput {
  categoryId: ID!
  allocationPercentage: Float!
}

type Query {
  login: LoginResponse!
  incomesList: IncomesList
  # TODO use this query to filter the incomes
  incomeById(incomeId: ID!): Income
  # TODO use this query to filter the expenses
  expenseById(id: ID!): Expense
  incomesGroupedBy: [IncomesGroupedBy!]
  incomesWithExpenses(input: FilterInput!): IncomesListAndExpenses!
  allExpenses: [Expense]
  # TODO refine this query
  financialBalanceByFortnight(input: PayBeforeInput!): FinancialBalance
  categoryList: [Categories!]
  categorySettings: CategorySettings
  categoryAllocation(input: CategoryAllocationInput!): CategoryAllocation
  cardList: [Card]
  cardById(cardId: ID!): Card
  periodsList: [Period!]
  period(input: FilterInput!): Period
}

type Mutation {
  createIncome(input: CreateIncomeInput!): Income!
  updateIncome(input: UpdateIncomeInput): Income
  deleteIncomeById(id: ID!): Boolean!
  createExpense(input: CreateExpenseInput!): Expense
  createFixedExpense(input: CreateFixedExpenseInput): [Expense]
  updateExpense(input: UpdateExpenseInput!): Expense!
  deleteExpense(id: ID!): Boolean!
  createCard(input: CreateCardInput): Card
  updateCard(input: UpdateCardInput): Card!
  deleteCard(id: ID!): Boolean!
  createCategorySetting(input: CreateCategorySettingInput!): CategorySetting!
  deleteCategorySetting(categoryId: ID!): CategorySetting!
}
